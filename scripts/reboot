#!/bin/bash

declare -r EXIT_SUCCESS=0
declare -r EXIT_ERROR=1
declare -r WATCHDOG_UTIL="/usr/local/bin/watchdogutil"
declare -r PRE_REBOOT_HOOK="pre_reboot_hook"

DEVPATH="/usr/share/sonic/device"
PLAT_REBOOT="platform_reboot"
PLATFORM_UPDATE_REBOOT_CAUSE="platform_update_reboot_cause"
REBOOT_CAUSE_FILE="/host/reboot-cause/reboot-cause.txt"
PLATFORM_REBOOT_PRE_CHECK="platform_reboot_pre_check"
REBOOT_TIME=$(date)

# Reboot immediately if we run the kdump capture kernel
VMCORE_FILE=/proc/vmcore
if [ -e $VMCORE_FILE -a -s $VMCORE_FILE ]; then
        echo "We have a /proc/vmcore, then we just kdump'ed"
        echo "Kernel Panic [Time: ${REBOOT_TIME}]" > ${REBOOT_CAUSE_FILE}
        sync
        PLATFORM=$(grep -oP 'sonic_platform=\K\S+' /proc/cmdline)
        if [ ! -z "${PLATFORM}" -a -x ${DEVPATH}/${PLATFORM}/${PLAT_REBOOT} ]; then
            exec ${DEVPATH}/${PLATFORM}/${PLAT_REBOOT}
        fi
        # If no platform-specific reboot tool, just run /sbin/reboot
        /sbin/reboot
        echo b > /proc/sysrq-trigger
fi

REBOOT_USER=$(logname)
PLATFORM=$(sonic-cfggen -H -v DEVICE_METADATA.localhost.platform)
ASIC_TYPE=$(sonic-cfggen -y /etc/sonic/sonic_version.yml -v asic_type)
SUBTYPE=$(sonic-cfggen -d -v DEVICE_METADATA.localhost.subtype)
ASAN=$(sonic-cfggen -y /etc/sonic/sonic_version.yml -v asan)
VERBOSE=no
EXIT_NEXT_IMAGE_NOT_EXISTS=4
EXIT_SONIC_INSTALLER_VERIFY_REBOOT=21
EXIT_PLATFORM_FW_AU_FAILURE=22
PLATFORM_FWUTIL_AU_REBOOT_HANDLE="platform_fw_au_reboot_handle"
PLATFORM_JSON_FILE="platform.json"
PLATFORM_JSON_PATH="${DEVPATH}/${PLATFORM}/${PLATFORM_JSON_FILE}"
REBOOT_SCRIPT_NAME=$(basename $0)
REBOOT_TYPE="${REBOOT_SCRIPT_NAME}"
TAG_LATEST=no
REBOOT_FLAGS=""
FORCE_REBOOT="no"
SMART_SWITCH="no"
DPU_MODULE_NAME=""
REBOOT_DPU="no"
PRE_SHUTDOWN="no"

function debug()
{
    if [[ x"${VERBOSE}" == x"yes" ]]; then
        echo `date` $@
    fi
    logger "$@"
}

function tag_images()
{
    if test -f /usr/local/bin/ctrmgr_tools.py
    then
        if [[ x"${TAG_LATEST}" == x"yes" ]]; then
            /usr/local/bin/ctrmgr_tools.py tag-all
        fi
    fi
}

function stop_pmon_service()
{
     CONTAINER_STOP_RC=0
     debug "Stopping pmon docker"
     systemctl stop pmon || debug "Ignore stopping pmon error $?"
     docker kill pmon &> /dev/null || CONTAINER_STOP_RC=$?
     if [[ CONTAINER_STOP_RC -ne 0 ]]; then
        debug "Failed killing container pmon RC $CONTAINER_STOP_RC ."
     fi
}

function stop_sonic_services()
{
    if [[ x"$SUBTYPE" == x"DualToR" ]]; then
        debug "DualToR detected, stopping mux container before reboot..."
        systemctl stop mux
    fi

    if [[ x"$ASIC_TYPE" != x"mellanox" ]]; then
        ASIC_CONF=${DEVPATH}/$PLATFORM/asic.conf
        if [ -f "$ASIC_CONF" ]; then
            source $ASIC_CONF
        fi
        if [[ ($NUM_ASIC -gt 1) ]]; then
            asic_num=0
            while [[ ($asic_num -lt $NUM_ASIC) ]]; do
                debug "Stopping syncd$asic_num process..."
                docker exec -i syncd$asic_num /usr/bin/syncd_request_shutdown --cold > /dev/null
                ((asic_num = asic_num + 1))
            done
        else
            debug "Stopping syncd process..."
            docker exec -i syncd /usr/bin/syncd_request_shutdown --cold > /dev/null
        fi
        sleep 3
    fi
    stop_pmon_service
}

function stop_services_asan()
{
    debug "Stopping swss for ASAN"
    systemctl stop swss
}

function clear_warm_boot()
{
    # If reboot is requested, make sure the outstanding warm-boot is cleared
    # So the system will come up from a cold boot.
    WARM_DIR="/host/warmboot"
    REDIS_FILE=dump.rdb
    TIMESTAMP=`date +%Y%m%d-%H%M%S`
    if [[ -f ${WARM_DIR}/${REDIS_FILE} ]]; then
        mv -f ${WARM_DIR}/${REDIS_FILE} ${WARM_DIR}/${REDIS_FILE}.${TIMESTAMP} || /bin/true
    fi
    /sbin/kexec -u || /bin/true
}

SCRIPT=$0

function show_help_and_exit()
{
    echo "Usage ${SCRIPT} [options]"
    echo "    Request rebooting the device. Invoke platform-specific tool when available."
    echo "    This script will shutdown syncd before rebooting."
    echo " "
    echo "    Available options:"
    echo "        -h, -? : getting this help"
    echo "        -d : DPU module name on a smart switch, option is invalid when on DPU"
    echo "        -p : Pre-shutdown steps on DPU, invalid on NPU"

    exit ${EXIT_SUCCESS}
}

function setup_reboot_variables()
{
    NEXT_SONIC_IMAGE=$(sonic-installer list | grep "Next: " | cut -d ' ' -f 2)
    IMAGE_PATH="/host/image-${NEXT_SONIC_IMAGE#SONiC-OS-}"
}

function reboot_pre_check()
{
    # Make sure that the file system is normal: read-write able
    filename="/host/test-`date +%Y%m%d-%H%M%S`"
    ERR=0
    touch ${filename} || ERR=$?
    if [[ ${ERR} -ne 0 ]]; then
        # Continue rebooting in this case, but log the error
        VERBOSE=yes debug "Filesystem might be read-only or full ..."
    fi
    rm ${filename}

    if [ -x ${DEVPATH}/${PLATFORM}/${PLATFORM_REBOOT_PRE_CHECK} ]; then
        ${DEVPATH}/${PLATFORM}/${PLATFORM_REBOOT_PRE_CHECK}
        [[ $? -ne 0 ]] && exit $?
    fi

    # Verify the next image by sonic-installer
    local message=$(sonic-installer verify-next-image 2>&1)
    if [ $? -ne 0 ]; then
        VERBOSE=yes debug "Failed to verify next image: ${message}"
        exit ${EXIT_SONIC_INSTALLER_VERIFY_REBOOT}
    fi
}

function check_conflict_boot_in_fw_update()
{
    # Make sure firmware auto update is not scheduled for a different reboot
    FIRMWARE_AU_STATUS_DIR="/tmp/firmwareupdate"
    FW_AU_TASK_FILE_REGEX="${FIRMWARE_AU_STATUS_DIR}/*_fw_au_task"
    FW_AU_TASK_FILE_EXP="${FIRMWARE_AU_STATUS_DIR}/cold_fw_au_task"
    FW_AU_TASK_FILE=$(compgen -G ${FW_AU_TASK_FILE_REGEX}) || true
    if [[ -n "${FW_AU_TASK_FILE}" ]] && [[ ! -f "${FW_AU_TASK_FILE_EXP}" ]]; then
        VERBOSE=yes debug "Firmware auto update scheduled for a different reboot: ${FW_AU_TASK_FILE}"
        exit ${EXIT_ERROR}
    fi
}

# Function to retrieve DPU IP from CONFIG_DB
function get_dpu_ip()
{
    local DPU_NAME=$1
    dpu_ip=$(sonic-db-cli CONFIG_DB HGET "DHCP_SERVER_IPV4_PORT|bridge-midplane|${DPU_NAME}" "ips@")
    if [ $? -ne 0 ] || [ -z "$dpu_ip" ]; then
        echo "Error: Failed to retrieve DPU IP address for ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi
    debug "$DPU_NAME ip: $dpu_ip"
}

# Function to retrieve GNMI port from CONFIG_DB
function get_gnmi_port() {
    local DPU_NAME=$1
    port=$(sonic-db-cli CONFIG_DB HGET "DPU_PORT|$DPU_NAME" "gnmi")
    if [ $? -ne 0 ] || [ -z "$port" ]; then
        echo "Error: Failed to retrieve GNMI port"
        exit ${EXIT_ERROR}
    fi
    debug "$DPU_NAME GNMI port:$port"
}

# Function to get reboot status from DPU
function get_reboot_status()
{
    local dpu_ip=$1
    local port=$2
    reboot_status=$(docker exec -i gnmi gnoi_client -target ${dpu_ip}:${port} -logtostderr -insecure -rpc RebootStatus)
    if [ $? -ne 0 ] || [ -z "$reboot_status" ]; then
        echo "Error: Failed to send reboot status command to DPU ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi
    debug "$reboot_status"
}

# Function to retrieve DPU bus info from platform JSON
function get_dpu_bus_info() {
    local DPU_NAME=$1
    DPU_BUS_INFO=$(jq -r --arg DPU_NAME "${DPU_NAME}" '.DPUS[] | select(has($DPU_NAME)) | .[$DPU_NAME].bus_info' "$PLATFORM_JSON_PATH")
    if [ -z "$DPU_BUS_INFO" ]; then
        echo "Error: bus_info not found for DPU ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi
    debug "$DPU_NAME : $DPU_BUS_INFO"
}

#Function to detach PCI module
function pci_detach_module() {
    local DPU_NAME=$1
    local DPU_BUS_INFO=$2
    status = $(python3 -c "import reboot_helper; reboot_helper.pci_detach_module('${DPU_NAME}')")
    if [ -z "$status" ] || [ "$status" = "false" ]; then
        echo 1 > /sys/bus/pci/devices/${DPU_BUS_INFO}/remove
    fi
}

# Function to reboot the platform module
function reboot_platform_module() {
    local DPU_NAME=$1
    reboot_status=$(python3 -c "import reboot_helper; reboot_helper.reboot_module('${DPU_NAME}')")
    if [ -z "$reboot_status" ] || [ "$reboot_status" = "false" ]; then
        echo "Error: Failed to reboot the platform"
        exit ${EXIT_ERROR}
    fi
}

function reboot_dpu_module()
{
    local DPU_NAME=$1
    local DPU_INDEX=${DPU_NAME//[!0-9]/}

    debug "User requested rebooting device ${DPU_NAME} ..."

    # Retrieve DPU IP and GNMI port
    dpu_ip=$(get_dpu_ip "${DPU_NAME}")
    port=$(get_gnmi_port "${DPU_NAME}")

    if [ -z "$dpu_ip" ] || [ -z "$port" ]; then
        echo "Error: Failed to retrieve DPU IP or GNMI port for ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi

    # Issue GNOI client command to reboot the DPU
    docker exec -i gnmi gnoi_client -target ${dpu_ip}:${port} -logtostderr -insecure -rpc Reboot -jsonin '{"method":3}'
    if [ $? -ne 0 ]; then
        echo "Error: Failed to send reboot command to DPU ${DPU_NAME}"
        exit ${EXIT_ERROR}
    fi

    # Retrieve dpu_halt_services_timeout value using jq
    dpu_halt_services_timeout=$(jq -r '.dpu_halt_services_timeout' "$PLATFORM_JSON_PATH" 2>/dev/null)
    if [ $? -ne 0 ]; then
        echo "Error: Failed to retrieve dpu_halt_services_timeout from ${PLATFORM_JSON_PATH}"
        exit ${EXIT_ERROR}
    fi

    # Poll on reboot status response with a timeout mechanism
    poll_interval=5
    waited_time=0
    while true; do
        reboot_status=$(get_reboot_status "${dpu_ip}" "${port}")
        debug "GNOI RebootStatus response ${reboot_status}"
        is_reboot_active=$(echo "$reboot_status" | grep "active" | awk '{print $2}')
        if [ "$is_reboot_active" == "false" ]; then
            break
        fi

        sleep "$poll_interval"
        waited_time=$((waited_time + poll_interval))
	    if [ $waited_time -ge $dpu_halt_services_timeout ]; then
            echo "Error: Timeout waiting for DPU ${DPU_NAME} to finish rebooting"
            exit ${EXIT_ERROR}
        fi
    done

    # Check if DPU exists and retrieve bus info
    DPU_BUS_INFO=$(get_dpu_bus_info "${DPU_NAME}")

    # Update STATE_DB and handle PCIe removal and rescan
    sonic-db-cli state_db set "PCIE_DETACH_INFO|${DPU_NAME}" '{"dpu_id": "'${DPU_INDEX}'", "dpu_state": "detaching", "bus_info": "'${DPU_BUS_INFO}'"}'

    pci_detach_module "${DPU_NAME}" "${DPU_BUS_INFO}"
    reboot_platform_module "${DPU_NAME}"
    echo 1 > /sys/bus/pci/rescan

    sonic-db-cli state_db del "PCIE_DETACH_INFO|${DPU_NAME}"
}

function parse_options()
{
    while getopts "h?vfpd" opt; do
        case ${opt} in
            h|\? )
                show_help_and_exit
                ;;
            v )
                VERBOSE=yes
                ;;
            t )
                TAG_LATEST=no
                ;;
            f )
                REBOOT_FLAGS+=" -f"
                ;;
            d )
                REBOOT_DPU="yes"
                DPU_MODULE_NAME="$OPTARG"
                ;;
            p )
                PRE_SHUTDOWN="yes"
                ;;
        esac
    done
}

function linecard_reboot_notify_supervisor()
{
    is_linecard=$(python3 -c 'from sonic_py_common import device_info; print("True") if device_info.is_chassis() == True and device_info.is_supervisor() == False else print("False")')
    if [ $is_linecard == "True" ]; then
        key=$(sonic-db-cli STATE_DB keys "CHASSIS_MODULE_TABLE|LINE-CARD*")
        status=$?
        if [ $status -eq 0 ]; then
            module="${key#CHASSIS_MODULE_TABLE}"
            if [ ! -z module ]; then
                sonic-db-cli CHASSIS_STATE_DB hset "CHASSIS_MODULE_REBOOT_INFO_TABLE${module}" "reboot" "expected"
                status=$?
                if [ $status -ne 0 ]; then
                    debug "Failed to notify Supervisor: Linecard reboot is expected"
                fi
            fi
        fi
    fi
}

# Function to reboot all DPUs in parallel
function reboot_all_dpus() {
    local NUM_DPU=$1

    for (( i=0; i<"$NUM_DPU"; i++ )); do
        echo "Rebooting DPU module dpu$i"
        reboot_dpu_module "dpu$i" &
    done
    wait
}

# Function to handle scenarios on smart switch
function handle_smart_switch() {
    if [ -f "$PLATFORM_JSON_PATH" ]; then
        NUM_DPU=$(jq -r '.DPUS | length' "$PLATFORM_JSON_PATH" 2>/dev/null)
        if [ "$NUM_DPU" -gt 0 ]; then
            SMART_SWITCH="yes"
        fi
    fi

    if [[ "$REBOOT_DPU" == "yes" ]]; then
        if [[ "$SMART_SWITCH" == "yes" ]]; then
            echo "User requested to reboot the device ${DPU_MODULE_NAME}"
            reboot_dpu_module "$DPU_MODULE_NAME"
        else
            echo "Invalid '-d' option specified for a non-smart switch"
            exit ${EXIT_ERROR}
        fi
    fi

    is_dpu=$(python3 -c "import reboot_helper; reboot_helper.is_dpu()")
    debug "Is the platform DPU: $is_dpu"

    # Check if system is a DPU and handle -p option accordingly
    if [[ "$is_dpu" == "True" && "$PRE_SHUTDOWN" != "yes" ]]; then
        echo "Invalid, '-p' option not specified for a DPU"
        exit ${EXIT_ERROR}
    elif [[ "$is_dpu" != "True" && "$PRE_SHUTDOWN" == "yes" ]]; then
        echo "Invalid '-p' option specified for a non-DPU"
        exit ${EXIT_ERROR}
    fi

    if [[ "$SMART_SWITCH" == "yes" ]]; then
        # If not a DPU, reboot all DPUs in parallel
        if [[ "$is_dpu" != "True" ]]; then
            reboot_all_dpus "$NUM_DPU"
        fi
    fi
}

parse_options $@

# Exit if not superuser
if [[ "$EUID" -ne 0 ]]; then
    echo "This command must be run as root" >&2
    exit ${EXIT_ERROR}
fi

debug "User requested rebooting device ..."

handle_smart_switch

check_conflict_boot_in_fw_update

setup_reboot_variables
reboot_pre_check

# Tag remotely deployed images as local
tag_images

# Linecard reboot notify supervisor
linecard_reboot_notify_supervisor

# Stop SONiC services gracefully.
stop_sonic_services

# Stop ASAN-enabled services so the report can be generated
if [[ x"$ASAN" == x"yes" ]]; then
    stop_services_asan
fi

clear_warm_boot

# Update the reboot cause file to reflect that user issued 'reboot' command
# Upon next boot, the contents of this file will be used to determine the
# cause of the previous reboot
echo "User issued 'reboot' command [User: ${REBOOT_USER}, Time: ${REBOOT_TIME}]" > ${REBOOT_CAUSE_FILE}
sync
/sbin/fstrim -av
sleep 3

# sync the current system time to CMOS
if [ -x /sbin/hwclock ]; then
    /sbin/hwclock -w || /bin/true
fi

if [[ -x ${DEVPATH}/${PLATFORM}/${PLATFORM_FWUTIL_AU_REBOOT_HANDLE} ]]; then
    debug "Handling task file for boot type ${REBOOT_TYPE}"
    ${DEVPATH}/${PLATFORM}/${PLATFORM_FWUTIL_AU_REBOOT_HANDLE} ${REBOOT_TYPE} || PLATFORM_FW_AU_RC=$?
    if [[ $PLATFORM_FW_AU_RC -ne 0 ]]; then
        debug "ERROR: Failed to handle the platform firmware auto-update for ${REBOOT_TYPE} Exit code: $PLATFORM_FW_AU_RC"
        exit "${EXIT_PLATFORM_FW_AU_FAILURE}"
    fi
fi

if [ -x ${DEVPATH}/${PLATFORM}/${PLATFORM_UPDATE_REBOOT_CAUSE} ]; then
    debug "updating reboot cause for ${PLATFORM}"
    ${DEVPATH}/${PLATFORM}/${PLATFORM_UPDATE_REBOOT_CAUSE}
fi

if [ -x ${DEVPATH}/${PLATFORM}/${PRE_REBOOT_HOOK} ]; then
    debug "Executing the pre-reboot script"
    ${DEVPATH}/${PLATFORM}/${PRE_REBOOT_HOOK}
    EXIT_CODE="$?"
    if [[ "${EXIT_CODE}" != "${EXIT_SUCCESS}" ]]; then
        debug "WARNING: Failed to handle pre-reboot script: rc=${EXIT_CODE}"
    fi
fi

if [ -x ${WATCHDOG_UTIL} ]; then
    debug "Enabling the Watchdog before reboot"
    ${WATCHDOG_UTIL} arm
fi

if [[ "${PRE_SHUTDOWN}" == "yes" ]]; then
    echo "${DPU_MODULE_NAME} pre-shutdown steps are completed"
    exit ${EXIT_SUCCESS}
fi

if [ -x ${DEVPATH}/${PLATFORM}/${PLAT_REBOOT} ]; then
    VERBOSE=yes debug "Rebooting with platform ${PLATFORM} specific tool ..."
    ${DEVPATH}/${PLATFORM}/${PLAT_REBOOT} $@

    # There are a couple reasons execution reaches here:
    #
    # 1. The vendor platform reboot returned after scheduled the platform specific reboot.
    #    This is a vendor platform reboot code bug but it happens.
    # 2. The vendor platform reboot failed. e.g. due to platform driver didn't load properly.
    #
    # As result if the reboot script reaches here. We should make the reboot happen.
    # Sleep 1 second before calling /sbin/reboot to accommodate situation #1 above.
    sleep 1

    VERBOSE=yes debug "Platform specific reboot failed!" >&2
fi

VERBOSE=yes debug "Issuing OS-level reboot ..." >&2
exec /sbin/reboot ${REBOOT_FLAGS}
